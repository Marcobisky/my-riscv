-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity COMP_GATE_UNSIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_UNSIGNED;

architecture Behavioral of COMP_GATE_UNSIGNED is
begin
  process(a, b)
  begin
    if (a > b ) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (a < b) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_LUT_LUT_inst_Decoder is
  port (
    n0: in std_logic;
    n1: in std_logic;
    n2: in std_logic;
    n3: in std_logic;
    n4: in std_logic;
    n5: in std_logic;
    n6: in std_logic;

    p_out: out std_logic_vector (3 downto 0)
);
end DIG_LUT_LUT_inst_Decoder;

architecture Behavioral of DIG_LUT_LUT_inst_Decoder is
  type mem is array ( 0 to 127) of std_logic_vector (3 downto 0);
  constant my_lut : mem := (
    "0000", "0000", "0000", "0101", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "1011", "0000", "0000", 
    "0000", "0010", "0000", "0000", "0000", "1001", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "1000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0111", "0000", "0000", 
    "0000", "1010", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0001", "0000", "0000", "0000", "0100", "0000", "0000", "0000", "0000", 
    "0000", "0000", "0000", "0110", "0000", "0000", "0000", "0011", "0000", 
    "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", "0000", 
    "0000", "1111");
  signal temp : std_logic_vector(6 downto 0);
begin
  temp <= n6 & n5 & n4 & n3 & n2 & n1 & n0;
  p_out <= my_lut(to_integer(unsigned(temp)));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DECODER_4 is
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    out_8: out std_logic;
    out_9: out std_logic;
    out_10: out std_logic;
    out_11: out std_logic;
    out_12: out std_logic;
    out_13: out std_logic;
    out_14: out std_logic;
    out_15: out std_logic;
    sel: in std_logic_vector (3 downto 0) );
end DECODER_4;

architecture Behavioral of DECODER_4 is
begin
  out_0 <= '1' when sel = "0000" else '0';
  out_1 <= '1' when sel = "0001" else '0';
  out_2 <= '1' when sel = "0010" else '0';
  out_3 <= '1' when sel = "0011" else '0';
  out_4 <= '1' when sel = "0100" else '0';
  out_5 <= '1' when sel = "0101" else '0';
  out_6 <= '1' when sel = "0110" else '0';
  out_7 <= '1' when sel = "0111" else '0';
  out_8 <= '1' when sel = "1000" else '0';
  out_9 <= '1' when sel = "1001" else '0';
  out_10 <= '1' when sel = "1010" else '0';
  out_11 <= '1' when sel = "1011" else '0';
  out_12 <= '1' when sel = "1100" else '0';
  out_13 <= '1' when sel = "1101" else '0';
  out_14 <= '1' when sel = "1110" else '0';
  out_15 <= '1' when sel = "1111" else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DECODER_3 is
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    sel: in std_logic_vector (2 downto 0) );
end DECODER_3;

architecture Behavioral of DECODER_3 is
begin
  out_0 <= '1' when sel = "000" else '0';
  out_1 <= '1' when sel = "001" else '0';
  out_2 <= '1' when sel = "010" else '0';
  out_3 <= '1' when sel = "011" else '0';
  out_4 <= '1' when sel = "100" else '0';
  out_5 <= '1' when sel = "101" else '0';
  out_6 <= '1' when sel = "110" else '0';
  out_7 <= '1' when sel = "111" else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity decoder_3bit is
  port (
    EN: in std_logic;
    Din: in std_logic_vector(2 downto 0);
    n0: out std_logic;
    n1: out std_logic;
    n2: out std_logic;
    n3: out std_logic;
    n4: out std_logic;
    n5: out std_logic;
    n6: out std_logic;
    n7: out std_logic);
end decoder_3bit;

architecture Behavioral of decoder_3bit is
  signal s0: std_logic_vector(7 downto 0);
  signal s1: std_logic_vector(7 downto 0);
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
begin
  gate0: entity work.DECODER_3
    port map (
      sel => Din,
      out_0 => s2,
      out_1 => s3,
      out_2 => s4,
      out_3 => s5,
      out_4 => s6,
      out_5 => s7,
      out_6 => s8,
      out_7 => s9);
  s0(0) <= s2;
  s0(1) <= s3;
  s0(2) <= s4;
  s0(3) <= s5;
  s0(4) <= s6;
  s0(5) <= s7;
  s0(6) <= s8;
  s0(7) <= s9;
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel => EN,
      in_0 => "00000000",
      in_1 => s0,
      p_out => s1);
  n0 <= s1(0);
  n1 <= s1(1);
  n2 <= s1(2);
  n3 <= s1(3);
  n4 <= s1(4);
  n5 <= s1(5);
  n6 <= s1(6);
  n7 <= s1(7);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DECODER_1 is
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    sel: in std_logic );
end DECODER_1;

architecture Behavioral of DECODER_1 is
begin
  out_0 <= '1' when sel = '0' else '0';
  out_1 <= '1' when sel = '1' else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity decoder_2bit is
  port (
    EN: in std_logic;
    Din: in std_logic;
    n0: out std_logic;
    n1: out std_logic);
end decoder_2bit;

architecture Behavioral of decoder_2bit is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic_vector(1 downto 0);
  signal s3: std_logic_vector(1 downto 0);
begin
  gate0: entity work.DECODER_1
    port map (
      sel => Din,
      out_0 => s0,
      out_1 => s1);
  s2(0) <= s0;
  s2(1) <= s1;
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => EN,
      in_0 => "00",
      in_1 => s2,
      p_out => s3);
  n0 <= s3(0);
  n1 <= s3(1);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DRIVER_INV_GATE_BUS is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    p_in: in std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic );
end DRIVER_INV_GATE_BUS;

architecture Behavioral of DRIVER_INV_GATE_BUS is
begin
  p_out <= p_in when sel = '1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity instruction_decoder is
  port (
    Instruction_In: in std_logic_vector(31 downto 0);
    EN: in std_logic;
    rd: out std_logic_vector(4 downto 0);
    rs1: out std_logic_vector(4 downto 0);
    rs2: out std_logic_vector(4 downto 0);
    imm_2531: out std_logic_vector(6 downto 0);
    imm_1231: out std_logic_vector(19 downto 0);
    imm_2032: out std_logic_vector(11 downto 0);
    invalid: out std_logic_vector(31 downto 0);
    mechie_op: out std_logic_vector(7 downto 0);
    csr_op: out std_logic_vector(5 downto 0);
    jmp_op: out std_logic_vector(8 downto 0);
    alu_op: out std_logic_vector(18 downto 0);
    mem_op: out std_logic_vector(8 downto 0);
    cust_op: out std_logic);
end instruction_decoder;

architecture Behavioral of instruction_decoder is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic_vector(3 downto 0);
  signal s8: std_logic_vector(31 downto 0);
  signal funct3: std_logic_vector(2 downto 0);
  signal rs1_temp: std_logic_vector(4 downto 0);
  signal rs2_temp: std_logic_vector(4 downto 0);
  signal imm_2531_temp: std_logic_vector(6 downto 0);
  signal n30: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal imm_2032_temp: std_logic_vector(11 downto 0);
  signal invalid_op0: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal jalr: std_logic;
  signal s15: std_logic;
  signal jal: std_logic;
  signal s16: std_logic;
  signal s17: std_logic;
  signal auipc: std_logic;
  signal lui: std_logic;
  signal s18: std_logic;
  signal s19: std_logic;
  signal ebreak: std_logic;
  signal ecall: std_logic;
  signal mret: std_logic;
  signal sfence_vma: std_logic;
  signal sret: std_logic;
  signal wfi: std_logic;
  signal fence: std_logic;
  signal fence_i: std_logic;
  signal csrrw: std_logic;
  signal csrrs: std_logic;
  signal csrrc: std_logic;
  signal csrrwi: std_logic;
  signal csrrsi: std_logic;
  signal csrrci: std_logic;
  signal beq: std_logic;
  signal bne: std_logic;
  signal blt: std_logic;
  signal bge: std_logic;
  signal bltu: std_logic;
  signal bgeu: std_logic;
  signal add: std_logic;
  signal sub: std_logic;
  signal p_sll: std_logic;
  signal slt: std_logic;
  signal sltu: std_logic;
  signal p_xor: std_logic;
  signal p_sra: std_logic;
  signal p_srl: std_logic;
  signal p_or: std_logic;
  signal p_and: std_logic;
  signal addi: std_logic;
  signal slli: std_logic;
  signal slti: std_logic;
  signal sltiu: std_logic;
  signal xori: std_logic;
  signal srli: std_logic;
  signal srai: std_logic;
  signal ori: std_logic;
  signal andi: std_logic;
  signal lb: std_logic;
  signal lh: std_logic;
  signal lw: std_logic;
  signal lbu: std_logic;
  signal lhu: std_logic;
  signal sb: std_logic;
  signal sh: std_logic;
  signal sw: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal invalid_op3: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal s26: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal s29: std_logic;
  signal s30: std_logic;
  signal s31: std_logic;
  signal s32: std_logic;
  signal s33: std_logic;
  signal s34: std_logic;
  signal s35: std_logic;
  signal s36: std_logic;
  signal s37: std_logic;
  signal s38: std_logic;
  signal s39: std_logic;
  signal s40: std_logic;
  signal s41: std_logic;
begin
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 32)
    port map (
      sel => EN,
      in_0 => "00000000000000000000000000000000",
      in_1 => Instruction_In,
      p_out => s8);
  gate1: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 32)
    port map (
      a => s8,
      b => "00010000001000000000000001110011",
      eq => sret);
  gate2: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 32)
    port map (
      a => s8,
      b => "00110000001000000000000001110011",
      eq => mret);
  gate3: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 32)
    port map (
      a => s8,
      b => "00010000010100000000000001110011",
      eq => wfi);
  s0 <= s8(0);
  s1 <= s8(1);
  s2 <= s8(2);
  s3 <= s8(3);
  s4 <= s8(4);
  s5 <= s8(5);
  s6 <= s8(6);
  rd <= s8(11 downto 7);
  funct3 <= s8(14 downto 12);
  rs1_temp <= s8(19 downto 15);
  rs2_temp <= s8(24 downto 20);
  imm_2531_temp <= s8(31 downto 25);
  gate4: entity work.DIG_LUT_LUT_inst_Decoder -- LUT_inst_Decoder
    port map (
      n0 => s0,
      n1 => s1,
      n2 => s2,
      n3 => s3,
      n4 => s4,
      n5 => s5,
      n6 => s6,
      p_out => s7);
  imm_2032_temp(4 downto 0) <= rs2_temp;
  imm_2032_temp(11 downto 5) <= imm_2531_temp;
  gate5: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 7)
    port map (
      a => imm_2531_temp,
      b => "0001001",
      eq => s20);
  n30 <= imm_2531_temp(5);
  s9 <= rs2_temp(0);
  s10 <= NOT (imm_2531_temp(0) OR imm_2531_temp(1) OR imm_2531_temp(2) OR imm_2531_temp(3) OR imm_2531_temp(4) OR n30 OR imm_2531_temp(6) OR rs2_temp(4) OR rs2_temp(3) OR rs2_temp(2) OR rs2_temp(1));
  imm_1231(2 downto 0) <= funct3;
  imm_1231(7 downto 3) <= rs1_temp;
  imm_1231(19 downto 8) <= imm_2032_temp;
  gate6: entity work.DECODER_4
    port map (
      sel => s7,
      out_0 => invalid_op0,
      out_1 => s12,
      out_2 => s13,
      out_3 => s14,
      out_4 => jalr,
      out_5 => s15,
      out_6 => jal,
      out_7 => s16,
      out_8 => s17,
      out_9 => auipc,
      out_10 => lui,
      out_11 => s18,
      out_15 => cust_op);
  s11 <= (s10 AND s9);
  s19 <= (s10 AND NOT s9);
  gate7: entity work.decoder_3bit
    port map (
      EN => s18,
      Din => funct3,
      n0 => fence,
      n1 => fence_i,
      n2 => s22,
      n3 => s23,
      n4 => s24,
      n5 => s25,
      n6 => s26,
      n7 => s27);
  gate8: entity work.decoder_3bit
    port map (
      EN => s17,
      Din => funct3,
      n0 => sb,
      n1 => sh,
      n2 => sw,
      n3 => s28,
      n4 => s29,
      n5 => s30,
      n6 => s31,
      n7 => s32);
  gate9: entity work.decoder_3bit
    port map (
      EN => s16,
      Din => funct3,
      n0 => s39,
      n1 => p_sll,
      n2 => slt,
      n3 => sltu,
      n4 => p_xor,
      n5 => s40,
      n6 => p_or,
      n7 => p_and);
  gate10: entity work.decoder_3bit
    port map (
      EN => s15,
      Din => funct3,
      n0 => lb,
      n1 => lh,
      n2 => lw,
      n3 => s33,
      n4 => lbu,
      n5 => lhu,
      n6 => s34,
      n7 => s35);
  gate11: entity work.decoder_3bit
    port map (
      EN => s12,
      Din => funct3,
      n0 => beq,
      n1 => bne,
      n2 => s36,
      n3 => s37,
      n4 => blt,
      n5 => bge,
      n6 => bltu,
      n7 => bgeu);
  gate12: entity work.decoder_3bit
    port map (
      EN => s13,
      Din => funct3,
      n0 => addi,
      n1 => slli,
      n2 => slti,
      n3 => sltiu,
      n4 => xori,
      n5 => s41,
      n6 => ori,
      n7 => andi);
  gate13: entity work.decoder_3bit
    port map (
      EN => s14,
      Din => funct3,
      n0 => s38,
      n1 => csrrw,
      n2 => csrrs,
      n3 => csrrc,
      n4 => invalid_op3,
      n5 => csrrwi,
      n6 => csrrsi,
      n7 => csrrci);
  csr_op(0) <= csrrw;
  csr_op(1) <= csrrs;
  csr_op(2) <= csrrc;
  csr_op(3) <= csrrwi;
  csr_op(4) <= csrrsi;
  csr_op(5) <= csrrci;
  jmp_op(0) <= jal;
  jmp_op(1) <= jalr;
  jmp_op(2) <= beq;
  jmp_op(3) <= bne;
  jmp_op(4) <= blt;
  jmp_op(5) <= bge;
  jmp_op(6) <= bltu;
  jmp_op(7) <= bgeu;
  jmp_op(8) <= auipc;
  mem_op(0) <= lui;
  mem_op(1) <= lb;
  mem_op(2) <= lh;
  mem_op(3) <= lw;
  mem_op(4) <= lbu;
  mem_op(5) <= lhu;
  mem_op(6) <= sb;
  mem_op(7) <= sh;
  mem_op(8) <= sw;
  s21 <= (EN AND (invalid_op0 OR (s36 OR s37) OR invalid_op3 OR (s33 OR s34 OR s35) OR (s28 OR s29 OR s30 OR s31 OR s32) OR (s22 OR s23 OR s24 OR s25 OR s26 OR s27)));
  gate14: entity work.MUX_GATE_1
    port map (
      sel => s38,
      in_0 => '0',
      in_1 => s11,
      p_out => ebreak);
  gate15: entity work.MUX_GATE_1
    port map (
      sel => s38,
      in_0 => '0',
      in_1 => s19,
      p_out => ecall);
  gate16: entity work.MUX_GATE_1
    port map (
      sel => s38,
      in_0 => '0',
      in_1 => s20,
      p_out => sfence_vma);
  gate17: entity work.decoder_2bit
    port map (
      EN => s39,
      Din => n30,
      n0 => add,
      n1 => sub);
  gate18: entity work.decoder_2bit
    port map (
      EN => s40,
      Din => n30,
      n0 => p_srl,
      n1 => p_sra);
  gate19: entity work.decoder_2bit
    port map (
      EN => s41,
      Din => n30,
      n0 => srli,
      n1 => srai);
  mechie_op(0) <= ebreak;
  mechie_op(1) <= ecall;
  mechie_op(2) <= mret;
  mechie_op(3) <= sfence_vma;
  mechie_op(4) <= sret;
  mechie_op(5) <= wfi;
  mechie_op(6) <= fence;
  mechie_op(7) <= fence_i;
  alu_op(0) <= add;
  alu_op(1) <= sub;
  alu_op(2) <= p_sll;
  alu_op(3) <= slt;
  alu_op(4) <= sltu;
  alu_op(5) <= p_xor;
  alu_op(6) <= p_sra;
  alu_op(7) <= p_srl;
  alu_op(8) <= p_or;
  alu_op(9) <= p_and;
  alu_op(10) <= addi;
  alu_op(11) <= slli;
  alu_op(12) <= slti;
  alu_op(13) <= sltiu;
  alu_op(14) <= xori;
  alu_op(15) <= srli;
  alu_op(16) <= srai;
  alu_op(17) <= ori;
  alu_op(18) <= andi;
  gate20: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 32)
    port map (
      p_in => "00000000000000000000000000000010",
      sel => s21,
      p_out => invalid);
  rs1 <= rs1_temp;
  rs2 <= rs2_temp;
  imm_2531 <= imm_2531_temp;
  imm_2032 <= imm_2032_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_Boot_B0 is
  port (
    D: out std_logic_vector (7 downto 0);
    A: in std_logic_vector (23 downto 0);
    sel: in std_logic );
end DIG_ROM_Boot_B0;

architecture Behavioral of DIG_ROM_Boot_B0 is
  type mem is array ( 0 to 33) of std_logic_vector (7 downto 0);
  constant my_Rom : mem := (
    "01111111", "11110011", "00110111", "10110111", "00110111", "10000011", 
    "00100011", "00010011", "10010011", "11100011", "00110111", "00010011", 
    "11110011", "11110011", "11110011", "11110011", "11110011", "11110011", 
    "11110011", "11110011", "11110011", "11110011", "11110011", "00110111", 
    "00010011", "11110011", "10010011", "00010011", "10010011", "00010011", 
    "10010011", "10010011", "10010111", "11100111");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "000000000000000000100001" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_Boot_B1 is
  port (
    D: out std_logic_vector (7 downto 0);
    A: in std_logic_vector (23 downto 0);
    sel: in std_logic );
end DIG_ROM_Boot_B1;

architecture Behavioral of DIG_ROM_Boot_B1 is
  type mem is array ( 0 to 33) of std_logic_vector (7 downto 0);
  constant my_Rom : mem := (
    "00000000", "00010010", "00000011", "00000011", "00111110", "01000101", 
    "10000000", "00000011", "10000011", "11101000", "00000011", "00000011", 
    "00010011", "00010011", "00010011", "00010011", "00010011", "00010011", 
    "00010011", "00010011", "00010011", "00010011", "00010011", "00101110", 
    "00001110", "00010011", "00000010", "00000011", "00000011", "00001110", 
    "00001110", "00000101", "00000000", "10000000");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "000000000000000000100001" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_Boot_B2 is
  port (
    D: out std_logic_vector (7 downto 0);
    A: in std_logic_vector (23 downto 0);
    sel: in std_logic );
end DIG_ROM_Boot_B2;

architecture Behavioral of DIG_ROM_Boot_B2 is
  type mem is array ( 0 to 25) of std_logic_vector (7 downto 0);
  constant my_Rom : mem := (
    "00000000", "00000000", "00000000", "00000000", "00000000", "00000011", 
    "10110011", "00010011", "00010011", "11000011", "00000000", "00000011", 
    "00010011", "00010000", "00100000", "00110000", "01000000", "01010000", 
    "00010000", "00100000", "00110000", "01000000", "01000000", "00000000", 
    "10001110", "00001110");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "000000000000000000011001" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_Boot_B3 is
  port (
    D: out std_logic_vector (7 downto 0);
    A: in std_logic_vector (23 downto 0);
    sel: in std_logic );
end DIG_ROM_Boot_B3;

architecture Behavioral of DIG_ROM_Boot_B3 is
  type mem is array ( 0 to 33) of std_logic_vector (7 downto 0);
  constant my_Rom : mem := (
    "10000000", "00110000", "01000000", "00000010", "00000010", "00000000", 
    "00000000", "00000000", "00000000", "11111111", "11000000", "00010000", 
    "00110000", "11110001", "11110001", "11110001", "11110001", "00110000", 
    "00110100", "00110100", "00110100", "00110100", "00110000", "00000000", 
    "10000000", "00110000", "00000000", "00000000", "00000000", "00000000", 
    "00000000", "00000000", "10000010", "11111000");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "000000000000000000100001" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity boot_rom is
  port (
    Addr: in std_logic_vector(23 downto 0);
    En: in std_logic;
    Out_code: out std_logic_vector(31 downto 0));
end boot_rom;

architecture Behavioral of boot_rom is
  signal s0: std_logic_vector(23 downto 0);
  signal s1: std_logic_vector(7 downto 0);
  signal s2: std_logic_vector(7 downto 0);
  signal s3: std_logic_vector(7 downto 0);
  signal s4: std_logic_vector(7 downto 0);
begin
  s0(21 downto 0) <= Addr(23 downto 2);
  s0(23 downto 22) <= "00";
  gate0: entity work.DIG_ROM_Boot_B0 -- Boot_B0
    port map (
      A => s0,
      sel => En,
      D => s1);
  gate1: entity work.DIG_ROM_Boot_B1 -- Boot_B1
    port map (
      A => s0,
      sel => En,
      D => s2);
  gate2: entity work.DIG_ROM_Boot_B2 -- Boot_B2
    port map (
      A => s0,
      sel => En,
      D => s3);
  gate3: entity work.DIG_ROM_Boot_B3 -- Boot_B3
    port map (
      A => s0,
      sel => En,
      D => s4);
  Out_code(7 downto 0) <= s1;
  Out_code(15 downto 8) <= s2;
  Out_code(23 downto 16) <= s3;
  Out_code(31 downto 24) <= s4;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DRIVER_INV_GATE_BUS is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    p_in: in std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic );
end DRIVER_INV_GATE_BUS;

architecture Behavioral of DRIVER_INV_GATE_BUS is
begin
  p_out <= p_in when sel = '0' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity program_counter is
  port (
    PC_inited: in std_logic;
    En: in std_logic;
    Clock: in std_logic;
    Addr_jmp: in std_logic_vector(31 downto 0);
    En_jmp: in std_logic;
    PC_next: out std_logic_vector(31 downto 0);
    PC_exec: out std_logic_vector(31 downto 0));
end program_counter;

architecture Behavioral of program_counter is
  signal s0: std_logic_vector(31 downto 0);
  signal s1: std_logic_vector(31 downto 0);
  signal PC_next_temp: std_logic_vector(31 downto 0);
  signal s2: std_logic;
  signal s3: std_logic_vector(31 downto 0);
  signal s4: std_logic_vector(31 downto 0);
  signal s5: std_logic_vector(31 downto 0);
  signal s6: std_logic_vector(31 downto 0);
  signal PC_exec_temp: std_logic_vector(31 downto 0);
begin
  s2 <= (En AND En_jmp);
  gate0: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 32)
    port map (
      p_in => "10000000000000000000000000000100",
      sel => PC_inited,
      p_out => PC_next_temp);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 32)
    port map (
      sel => s2,
      in_0 => s1,
      in_1 => Addr_jmp,
      p_out => s3);
  gate2: entity work.DIG_Register_BUS -- PC_reg
    generic map (
      Bits => 32)
    port map (
      D => s4,
      C => Clock,
      en => En,
      Q => s5);
  gate3: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 32)
    port map (
      p_in => s5,
      sel => PC_inited,
      p_out => s6);
  gate4: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 32)
    port map (
      sel => PC_inited,
      in_0 => "10000000000000000000000000000000",
      in_1 => PC_exec_temp,
      p_out => s0);
  gate5: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 32)
    port map (
      sel => PC_inited,
      in_0 => "10000000000000000000000000000000",
      in_1 => s6,
      p_out => PC_exec_temp);
  gate6: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 32)
    port map (
      sel => PC_inited,
      in_0 => PC_next_temp,
      in_1 => s3,
      p_out => s4);
  gate7: entity work.DIG_Add
    generic map (
      Bits => 32)
    port map (
      a => s0,
      b => "00000000000000000000000000000100",
      c_i => '0',
      s => s1);
  PC_next <= PC_next_temp;
  PC_exec <= PC_exec_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity cust_ctrl is
  port (
    op_code: in std_logic_vector(31 downto 0);
    cust_code: in std_logic;
    Clock: in std_logic;
    PC_init: out std_logic);
end cust_ctrl;

architecture Behavioral of cust_ctrl is
  signal s0: std_logic_vector(31 downto 0);
  signal s1: std_logic_vector(11 downto 0);
  signal s2: std_logic_vector(11 downto 0);
begin
  gate0: entity work.DRIVER_INV_GATE_BUS
    generic map (
      Bits => 32)
    port map (
      p_in => op_code,
      sel => cust_code,
      p_out => s0);
  s1 <= s0(31 downto 20);
  gate1: entity work.DIG_Register_BUS
    generic map (
      Bits => 12)
    port map (
      D => s1,
      C => Clock,
      en => cust_code,
      Q => s2);
  PC_init <= s2(11);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    Clock: in std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic_vector(31 downto 0);
  signal addr_real: std_logic_vector(23 downto 0);
  signal addrflag_memtmp: std_logic;
  signal addrflag_boot: std_logic;
  signal instruction_code: std_logic_vector(31 downto 0);
  signal rd: std_logic_vector(4 downto 0);
  signal rs1: std_logic_vector(4 downto 0);
  signal rs2: std_logic_vector(4 downto 0);
  signal imm_7: std_logic_vector(6 downto 0);
  signal imm_20: std_logic_vector(19 downto 0);
  signal imm_12: std_logic_vector(11 downto 0);
  signal Invalid_op: std_logic_vector(31 downto 0);
  signal mechine_op: std_logic_vector(7 downto 0);
  signal csr_op: std_logic_vector(5 downto 0);
  signal jmp_op: std_logic_vector(8 downto 0);
  signal alu_op: std_logic_vector(18 downto 0);
  signal mem_op: std_logic_vector(8 downto 0);
  signal Cust_op: std_logic;
  signal s1: std_logic;
begin
  gate0: entity work.instruction_decoder
    port map (
      Instruction_In => instruction_code,
      EN => '1',
      rd => rd,
      rs1 => rs1,
      rs2 => rs2,
      imm_2531 => imm_7,
      imm_1231 => imm_20,
      imm_2032 => imm_12,
      invalid => Invalid_op,
      mechie_op => mechine_op,
      csr_op => csr_op,
      jmp_op => jmp_op,
      alu_op => alu_op,
      mem_op => mem_op,
      cust_op => Cust_op);
  gate1: entity work.boot_rom
    port map (
      Addr => addr_real,
      En => addrflag_boot,
      Out_code => instruction_code);
  gate2: entity work.program_counter
    port map (
      PC_inited => s1,
      En => '1',
      Clock => Clock,
      Addr_jmp => "00000000000000000000000000000000",
      En_jmp => '0',
      PC_exec => s0);
  gate3: entity work.cust_ctrl
    port map (
      op_code => instruction_code,
      cust_code => Cust_op,
      Clock => Clock,
      PC_init => s1);
  addr_real <= s0(23 downto 0);
  addrflag_memtmp <= s0(25);
  addrflag_boot <= s0(31);
end Behavioral;
